<img src="https://github.com/billbuchanan/csn09112/blob/master/zadditional/top_csn09112.png"/>


# CSN09112 - Network Security and Cryptography
Author: Bill Buchanan

## Running the bot and controller
You can download the Bot onto the Linux machine using:

```
wget 'https://github.com/billbuchanan/csn09112/blob/master/coursework/cw_2025_2026.zip?raw=true'
mv cw_2025_2026.zip?raw=true cw2025_2026.zip
unzip cw2025_2026.zip
```


Set up the controller to run on Linux and the botnet to run on Windows. Go to your Windows machine on the DMZ and download the ZIP file. You can run the controller on our Linux machine with:</p>

```
mono c.exe
```

The output should show the form of:

```
Bot Controller Version 8.1
```

Take a note of the IP address of the controller (W.X.Y.Z). Now go to your Windows machine, and run:</p>

```
b.exe W.X.Y.Z MATRIC
```
and where MATRIC is your Matriculation Number.

```
Bot Version 8.1 - 2025/2026
Please run with bot w.x.y.z, where w.x.y.z is the address of your controller.
Hello 111111
```

The bot and the controller should connect to each other. A sample Wireshark trace is [here](https://github.com/billbuchanan/csn09112/blob/master/coursework/cw.zip).

Note: **The bot and controller use TCP Ports 5000-5010, so please open them up on your firewall**

## Outline Requirements

Botnets are a particular problem and where bot agents may infect machines inside an organisation’s network and connect back to a botnet controller that can receive commands and undertake malicious activities. The focus of this coursework is to create a virtualised testbed environment to analyse a particular botnet agent and the communications to its controller, and then to create and test a detection system to detect its activities. Tasks include:

*	Setup cloud instances of your evaluation infrastructure. This should include a Windows server host and a Linux server. Snort should be installed on both machines and will detect network traffic generated by the bot and the controller. If you cannot get a Linux and Windows instance set up, it is acceptable to run the bot and controller on the same machine.
*	Analyse the operation of the running Bot agent and Botnet controller, including any network scanning by the bot, activity on the host, network connections created, and any communications between the bot and controller.
*	Create and test a detection system for the Botnet agent and controller using an IDS sensor. 


Your network architecture should be similar to that shown in Figure 1 and should be created with the VMs provided using two private address spaces. The Bot agent should be run from the internal trusted Private network.

Start by allowing all traffic from the internal network out to the external network so the bot can communicate with the bot controller. Then, use this architecture as your testbed to thoroughly investigate and analyse the Botnet activity. Try to plan and be scientific in the experimental method you use and don’t simply run it once and report. Static analysis can then be used to complement the dynamic analysis. After this, design an Intrusion Detection System (IDS) which will detect the various bot activities, leading to an implementation of a prototype using a Snort sensor running on the internal Linux system. The alerts generated should be useful to a security admin. If you have time investigate tuning the rules. Once the IDS has been tested, design and create firewall rules to close down the firewall to prevent future botnet activity, possibly highlight/log specific botnet activity, and test the configuration. Finally, the botnet can be tested within the vSoC environment.

![Figure 1](https://github.com/billbuchanan/csn09112/blob/master/zadditional/coursework01.png)

The controller and the bot should be placed on different hosts, and then enabled to communicate. It is then your task to capture and analyse the traffic generated and try and build up an understanding of the requests and replies that are used by the bot and controller. Once you understand the requests and replies, then create a Snort-based IDS detector to detect the presence of the Bot and Controller.

## Marking schedule

The coursework should be submitted via Turnitin (submit.ac.uk) in a PDF format, if possible. The hand-in date is Friday 19 December 2025 (11:55pm). It will be marked as follows:

### Research [20 marks]

A brief literature review towards your botnet analysis method and IDS rule development, demonstrating an understanding of the topics and using research from a variety of quality sources (cited in the text). Try to include some critical analysis - for example, strengths and weaknesses, justification, and highlighting findings which inform the later work - and possibly recent examples and how they were analysed.
<p align="right">[20 marks]</p>

### Botnet Analysis [40 marks]

Analyse the operation of the running Bot agent and Botnet controller, including any connections created by the bot, host activities on the victim, any communications between the bot and controller, and any network scanning by the bot. For example, screenshots and brief discussion for: botnet components running, analysis tools, outputs and interesting data, tools and outputs of cracking codes, with a brief discussion.  

*	Dynamic analysis of bot and botnet controller
1. Identifying botnet network connections and traffic, filtering out unrelated traffic using appropriate tools such as Wireshark
2. Identify types of traffic, reconnaissance/command and control traffic
3. Identify specific botnet commands and responses
4. Decode botnet traffic if necessary – some may be encoded/encrypted! Crack the messages for extra marks
5. Challenge: create your own bot traffic so individual commands can be sent and analysed separately
*	Challenge: To verify your findings from the dynamic analysis of the botnet behaviour, try to reverse engineer the bot agent code and statically analyse the code.


### IDS Detector [30 marks]
From your botnet analysis, create and test a basic prototype detection system for the Botnet agent and controller using an IDS sensor.  Create IDS rules/signatures to detect the bot activity and not excessive many false positives. This section could show the Snort rules with descriptions of how they work, and screenshots of the testing/outputs and discussion on this. 


### References/Presentation [10 marks]

The academic report should be written in a formal style, in 3rd person, and well presented.
Full academic referencing of peer-reviewed papers, technical papers, books, and websites, using the IEEE referencing format.
- Reference all materials used, citing every reference in the body of the report.
- All references cited should be listed at the end of the report, using IEEE referencing format.


The report should use the Harvard format for all of the references and, if possible, should include EVERY reference to material sourced from other places. Also, the report should be up to 20 pages long (where appendices do not count in the page count number). 

# Usage of AI tools
The use of AI tools is not recommended for any part of this coursework. Any use of them **must** be referenced within the coursework - and for all instances of their usage. The coursework should also contain a statement at the start of the coursework which defines whether AI tools have been used or not and a justification for their usage, such as:

```
This coursework does not contain any usage of AI tools and is the sole work of the author
```

or:

```
This coursework contains the usage of AI tools with Section X.X and Section X.Y. These have been used because [give justification].
```
# Helper
This section contains a helper section for you to get Snort to work.

## Coursework Prep (Snort on Windows)
If you prefer Linux, you can follow the main steps of the section, but use Linux commands. 

Set up a Microsoft Windows server (from AWS), the Windows server on vSoC or your laptop, and then install Snort V 2.9 [here](https://www.snort.org/downloads/snort/Snort_2_9_20_Installer.x64.exe) in the folder c:\snort. Next, locate the snort.exe (c:\snort\bin\snort.exe) program and download the coursework as a pcap file [here](http://asecuritysite.com/cw.zip). Next, create a rules file to detect the connection between the bot and the controller, and save it as cw.rules:

```
# Connection detection
alert tcp any any -> any 5000 (msg:"Port 5000";sid:10000)
alert tcp any any -> any 5001 (msg:"Port 5001";sid:10001)
alert tcp any any -> any 5002 (msg:"Port 5002";sid:10002)
alert tcp any any -> any 5003 (msg:"Port 5003";sid:10003)
alert tcp any any -> any 5004 (msg:"Port 5004";sid:10004)
alert tcp any any -> any 5005 (msg:"Port 5005";sid:10005)


# Content detection (e.g. "bye")
alert tcp any any -> any 5000 (msg:"Port 5000 command bye"; content:"bye"; sid:11000)
alert tcp any any -> any 5001 (msg:"Port 5001 command bye"; content:"bye"; sid:11001)
alert tcp any any -> any 5002 (msg:"Port 5002 command bye"; content:"bye"; sid:11002)
alert tcp any any -> any 5003 (msg:"Port 5003 command bye"; content:"bye"; sid:11003)
alert tcp any any -> any 5004 (msg:"Port 5004 command bye"; content:"bye"; sid:11004)
alert tcp any any -> any 5005 (msg:"Port 5005 command bye"; content:"bye"; sid:11005)

# Some additional pre-processor things
preprocessor stream5_global: track_tcp yes, \
track_udp yes, \
track_icmp no, \
max_tcp 262144, \
max_udp 131072, \
max_active_responses 2, \
min_response_seconds 5
preprocessor stream5_tcp: policy windows, detect_anomalies, require_3whs 180, \
overlap_limit 10, small_segments 3 bytes 150, timeout 180, \
ports client 21 22 23 25 42 53 70 79 109 110 111 113 119 135 136 137 139 143 \
161 445 513 514 587 593 691 1433 1521 1741 2100 3306 6070 6665 6666 6667 6668 6669 \
7000 8181 32770 32771 32772 32773 32774 32775 32776 32777 32778 32779, \
ports both 80 81 82 83 84 85 86 87 88 89 90 110 311 383 443 465 563 591 593 631 636 901 989 992 993 994 995 1220 1414 1830 2301 2381 2809 3037 3057 3128 3443 3702 4343 4848 5250 6080 6988 7907 7000 7001 7144 7145 7510 7802 7777 7779 \
7801 7900 7901 7902 7903 7904 7905 7906 7908 7909 7910 7911 7912 7913 7914 7915 7916 \
7917 7918 7919 7920 8000 8008 8014 8028 8080 8085 8088 8090 8118 8123 8180 8222 8243 8280 8300 8500 8800 8888 8899 9000 9060 9080 9090 9091 9443 9999 10000 11371 34443 34444 41080 50000 50002 55555
preprocessor stream5_udp: timeout 180

```


Now, create a subfolder named log:

```
mkdir log
```

Now run with:

```
c:\snort\bin\snort.exe -c cw.rules -r cw.pcap -k none -l log
```
The reason for the -k none is that we have checksum errors in the Wireshark packets:
```
All Discard:            0 (  0.000%)
      Other:            0 (  0.000%)
Bad Chk Sum:          121 (100.000%)
    Bad TTL:            0 (  0.000%)
     S5 G 1:            0 (  0.000%)
     S5 G 2:            0 (  0.000%)
      Total:          121
```
Your alerts should be in the log\alert.ids folder. An example is:

```
[**] [1:10000:0] Port 5000 [**]
[Priority: 0] 
11/13-15:03:10.666719 10.0.0.106:59444 -> 10.0.0.106:5000
TCP TTL:128 TOS:0x2 ID:55884 IpLen:20 DgmLen:49 DF
***AP*** Seq: 0x9A03111F  Ack: 0xC0DAF0E7  Win: 0x27F9  TcpLen: 20

[**] [1:10000:0] Port 5000 [**]
[Priority: 0] 
11/13-15:03:10.666917 10.0.0.106:59444 -> 10.0.0.106:5000
TCP TTL:128 TOS:0x0 ID:55887 IpLen:20 DgmLen:40 DF
***A**** Seq: 0x9A031128  Ack: 0xC0DAF1E2  Win: 0x27F8  TcpLen: 20

[**] [1:11000:0] Port 5000 command bye [**]
[Priority: 0] 
11/13-15:03:13.689070 10.0.0.106:59444 -> 10.0.0.106:5000
TCP TTL:128 TOS:0x2 ID:55888 IpLen:20 DgmLen:45 DF
***AP*** Seq: 0x9A031128  Ack: 0xC0DAF1E2  Win: 0x27F8  TcpLen: 20
```

What do you examine from the contents of this file (alert.ids)?

We can see that the connection to Port 5000 was detected twice, and that the "bye" command was also detected.

Now we will detect a range of ports with:

```
alert tcp any any -> any 5000:5005 (msg:"Command 'bye'"; content:"bye"; sid:11000)
```

This now gives:

```
[**] [1:11000:0] Command 'bye' [**]
[Priority: 0] 
11/13-15:03:13.689070 10.0.0.106:59444 -> 10.0.0.106:5000
TCP TTL:128 TOS:0x2 ID:55888 IpLen:20 DgmLen:45 DF
***AP*** Seq: 0x9A031128  Ack: 0xC0DAF1E2  Win: 0x27F8  TcpLen: 20
```
Next, we can detect the controller response of "MYzJQjYmKdJkBxEe87tDowzbefGKZCYM1VmmRfLf2A4=" with:

```
alert tcp any 5000:5005 -> any any (msg:"Command 'MYz Base64 detected'"; content:"MYzJQjYmKdJkBxEe87tDowzbefGKZCYM1VmmRfLf2A4=";nocase; sid:11001)

```
This gives:

```
[**] [1:11001:0] Command 'MYz Base64 detected' [**]
[Priority: 0] 
11/13-15:03:27.029538 10.0.0.106:5000 -> 10.0.0.106:59446
TCP TTL:128 TOS:0x2 ID:55911 IpLen:20 DgmLen:86 DF
***AP*** Seq: 0x6EE75791  Ack: 0xFF366CED  Win: 0x27F9  TcpLen: 20
```

Now, try this approach on the pcap file that you have captured for the coursework, and try to detect the commands that the bot sends to the controller.

Now, try this approach on the pcap file that you have captured for the coursework, and try to detect the commands that the controller sends to the bot.

## Setting up the bot and the controller
Run the controller first and it will wait for a connection from the bot. Now run the bot with the IP address of the controller. The bot will run for a short time, and then stop. Make sure that you run Wireshark to listen to the traffic between the bot and the controller. A sample Wireshark trace is [here](https://github.com/billbuchanan/csn09112/blob/master/coursework/cw.zip).

Note: The bot and controller use TCP Ports 5000-5010, so please open them up on your firewall

